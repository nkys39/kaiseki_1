# 既存地図とSLAMの関係

## 1. 概要

本システムの自己位置推定は、**現在のLRFスキャンデータ**を**参照用マップ**とマッチングすることで行われます。

重要な点として、マッチングの対象となる**参照用マップ**はSLAMモードによって異なります：

- **通常SLAMモード**: LRFスキャンで**構築したSLAMマップ**が参照用マップ
- **CADマッチングモード**: **CAD図面から変換したマップ**が参照用マップ

つまり、**LRFの生データを直接CAD図面とマッチングしているのではなく**、すべてのモードで**マップ形式に変換されたデータ同士**をマッチングしています。

---

## 2. SLAMモードの種類

設定ファイル `Setting.ini` の `SLAMMODE` パラメータで動作モードを切り替えられます：

| モード | 説明 | 使用するマップ |
|--------|------|----------------|
| **0** | 通常SLAM | リアルタイム構築マップ (map) |
| **1** | CAD図面マッチング | CAD図面マップ (cad_map) |
| **2** | エッジCADマッチング | エッジ抽出マップ (edge_map) |

### 2.1 モード0: 通常SLAM
```cpp
// main.cpp:1831
if (slamMode == 0) {
    slam(robot_pos, data, baseMap.map, baseMap.map2, poutp);
}
```
- LRFデータから**リアルタイムに地図を構築**
- 構築した地図とLRFデータをマッチングして自己位置推定
- 未知環境での探索に適している

### 2.2 モード1: CAD図面マッチング
```cpp
// main.cpp:1840
else if (slamMode == 1) {
    slam(robot_pos, data, baseMap.cad_map, baseMap.cad_map2, poutp);
}
```
- **事前にCAD図面から変換した地図**を使用
- LRFデータとCAD図面をマッチングして自己位置推定
- 地図構築は行わない（既存地図のみ使用）

### 2.3 モード2: エッジCADマッチング
```cpp
// main.cpp:1852
slam(robot_pos, data, baseMap.edge_map, baseMap.edge_map2, poutp);
```
- CAD図面から**壁のエッジのみを抽出**した地図を使用
- 家具や機器などのノイズを除去した「クリーンな壁面」でマッチング
- マッチング精度が向上する場合がある

---

## 3. マップデータの種類と役割

### 3.1 マップ構造体 (org_map)
```cpp
struct org_map {
    int **map;        // SLAMで構築する占有マップ
    int **map2;       // SLAMで構築する累積マップ
    int **cad_map;    // CAD図面から変換したマップ
    int **cad_map2;   // CAD累積マップ
    int **edge_map;   // エッジ抽出後のマップ
    int **edge_map2;  // エッジ累積マップ
    int width, height;
};
```

### 3.2 各マップの役割

```
┌─────────────────────────────────────────────────────────────────┐
│                       マップの階層構造                           │
├─────────────────────────────────────────────────────────────────┤
│                                                                  │
│  ┌───────────────────┐                                          │
│  │   CAD図面 (PNG)   │ ← 入力: 建物の図面画像                   │
│  └─────────┬─────────┘                                          │
│            │                                                     │
│            ▼                                                     │
│  ┌───────────────────┐                                          │
│  │     cad_map       │ ← ピクセル値200未満を障害物として変換    │
│  │  (CAD図面マップ)  │    値100 = 障害物、0 = 空き              │
│  └─────────┬─────────┘                                          │
│            │                                                     │
│            ▼ (edge_cadフラグが有効な場合)                       │
│  ┌───────────────────┐                                          │
│  │  regiongrowing    │ ← 領域拡張法でエッジ抽出                 │
│  │  (エッジ抽出処理) │    初期位置から走査可能領域を探索        │
│  └─────────┬─────────┘                                          │
│            │                                                     │
│            ▼                                                     │
│  ┌───────────────────┐                                          │
│  │     edge_map      │ ← 壁面の輪郭のみを抽出したマップ        │
│  │ (エッジマップ)    │    ノイズ除去済み                        │
│  └─────────┬─────────┘                                          │
│            │                                                     │
│            ▼                                                     │
│  ┌───────────────────┐                                          │
│  │   multi_map       │ ← 多解像度マップを生成                   │
│  │  (多解像度マップ) │    解像度1, 2, 4, 8...                   │
│  └─────────┬─────────┘                                          │
│            │                                                     │
│            ▼                                                     │
│  ┌───────────────────────────────────────────────────────────┐  │
│  │                    SLAMアルゴリズム                        │  │
│  │  ┌─────────────────┐    ┌─────────────────┐              │  │
│  │  │ 初期位置推定     │    │ 逐次位置推定     │              │  │
│  │  │ (localization)  │    │ (slam)          │              │  │
│  │  │                 │    │                 │              │  │
│  │  │ LRFデータと     │    │ LRFデータと     │              │  │
│  │  │ multi_mapを     │───▶│ 選択されたmapを │              │  │
│  │  │ マッチング      │    │ マッチング      │              │  │
│  │  └─────────────────┘    └─────────────────┘              │  │
│  └───────────────────────────────────────────────────────────┘  │
│                                                                  │
└─────────────────────────────────────────────────────────────────┘
```

---

## 4. マッチング処理の詳細

### 4.1 マッチング処理の正確な理解

**重要**: マッチングは以下のように行われます：

```
┌─────────────────────────────────────────────────────────────────┐
│                   マッチング処理の実態                          │
├─────────────────────────────────────────────────────────────────┤
│                                                                  │
│  ┌────────────────┐                                             │
│  │ 現在のLRFスキャン │ ← lrf_data[] (距離・角度の生データ)      │
│  └────────┬───────┘                                             │
│           │                                                      │
│           ▼ 座標変換 (slam.cpp:738-752)                         │
│  ┌────────────────┐                                             │
│  │   x[], y[]     │ ← LRFスキャンの直交座標表現                 │
│  │ (グローバル変数) │    x[i] = lrf_data[i] * sin(theta[i])     │
│  └────────┬───────┘    y[i] = lrf_data[i] * cos(theta[i])      │
│           │                                                      │
│           │                                                      │
│           ▼ fitcal_m() でマッチング                             │
│  ┌────────────────────────────────────────────────────────────┐ │
│  │                                                             │ │
│  │  現在のスキャン (x[], y[])                                  │ │
│  │         ↓                                                   │ │
│  │  候補位置 (gen_m[i]) で座標変換                             │ │
│  │         ↓                                                   │ │
│  │  参照用マップ (omap, amap) と照合                           │ │
│  │         ↓                                                   │ │
│  │  一致度 (適合度) を計算                                     │ │
│  │                                                             │ │
│  └────────────────────────────────────────────────────────────┘ │
│                                                                  │
│  ※ 参照用マップ (omap, amap) はモードによって異なる：           │
│                                                                  │
│  ┌─────────────────────────────────────────────────────────┐    │
│  │ slamMode == 0: baseMap.map, baseMap.map2               │    │
│  │                (SLAMで構築した占有確率マップ)            │    │
│  ├─────────────────────────────────────────────────────────┤    │
│  │ slamMode == 1: baseMap.cad_map, baseMap.cad_map2       │    │
│  │                (CAD図面から変換したマップ)              │    │
│  ├─────────────────────────────────────────────────────────┤    │
│  │ slamMode == 2: baseMap.edge_map, baseMap.edge_map2     │    │
│  │                (エッジ抽出後のマップ)                    │    │
│  └─────────────────────────────────────────────────────────┘    │
│                                                                  │
└─────────────────────────────────────────────────────────────────┘
```

### 4.2 スキャンマッチングの原理

LRFで取得した点群データを、参照用マップ上の障害物位置と照合することで自己位置を推定します。

```
┌────────────────────────────────────────────────────────────────┐
│                  スキャンマッチングの流れ                       │
├────────────────────────────────────────────────────────────────┤
│                                                                 │
│  1. LRFデータ取得                                              │
│     ┌─────────────────┐                                        │
│     │   ロボット      │                                        │
│     │     ◯─────────● 距離d, 角度θ                          │
│     │       \                                                  │
│     │        \______● 距離d, 角度θ                           │
│     │               \                                          │
│     │                ● 障害物検出点                           │
│     └─────────────────┘                                        │
│                                                                 │
│  2. 候補位置での点群変換                                       │
│     仮の位置(x, y, θ)から見た場合の                           │
│     LRF点群のワールド座標を計算                                │
│                                                                 │
│     x' = x_lrf * cos(θ) - y_lrf * sin(θ) + x                  │
│     y' = x_lrf * sin(θ) + y_lrf * cos(θ) + y                  │
│                                                                 │
│  3. マップとの一致度計算                                       │
│     変換後の点群が既存地図の障害物位置と                       │
│     どれだけ一致するかを評価                                   │
│                                                                 │
│     ┌─────────────────────────────────────┐                   │
│     │ ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░│ 既存地図           │
│     │ ░░░░░████████░░░░░░░░░░░░░░░░░░░│                     │
│     │ ░░░░░█      █░░░●●●░░░░░░░░░░░░│ ← LRF点群          │
│     │ ░░░░░█      █░░●░░░░░░░░░░░░░░░│   (変換後)          │
│     │ ░░░░░█      █●░░░░░░░░░░░░░░░░░│                     │
│     │ ░░░░░████████░░░░░░░░░░░░░░░░░░│                     │
│     │ ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░│                     │
│     └─────────────────────────────────┘                       │
│                                                                 │
│     一致度 = 障害物上に乗った点数 / 全点数                     │
│                                                                 │
│  4. 遺伝的アルゴリズムで最適位置探索                           │
│     複数の候補位置(x, y, θ)を生成                             │
│     一致度が最も高い位置を選択                                 │
│                                                                 │
└────────────────────────────────────────────────────────────────┘
```

### 4.2 適合度関数 (fitcal_m / fitcal_p)

```cpp
// slam.cpp: fitcal_m() - 逐次位置推定用
double fitcal_m(int i, robot_position *robot, int **omap, int **amap) {
    // 候補位置iでのLRF点群のワールド座標変換
    for (各LRF点) {
        x_3 = x * c1 - y * s1 + x_c2;  // 回転 + 平行移動
        y_3 = x * s1 + y * c1 + y_c2;

        // マップ座標に変換
        pt_x = (map_center - x_3 / map_rate);
        pt_y = (map_center - y_3 / map_rate);

        // amap（累積マップ）で一致判定
        if (amap[pt_x][pt_y] > 0) {
            hit++;  // 障害物と一致
        }

        // omap（確率マップ）で確率計算
        probability = cal_probability(omap[pt_x][pt_y]);
        if (probability > 0.3) {
            hit2++;
        }
    }

    // 複合適合度を返す
    return (hit / total) * (hit2 / total);
}
```

### 4.3 初期位置推定での使用

```cpp
// localization.cpp: fitcal_p() - 初期位置推定用
double fitcal_p(int fx, int fy, double fr, multi_map *multi_Map) {
    // 多解像度マップを使用してマッチング
    // multi_Map->norm と multi_Map->anorm で評価

    for (各LRF点) {
        // 候補位置(fx, fy, fr)での座標変換
        x_3 = x_1 * c1 - y_1 * s1 + x_c2;
        y_3 = x_1 * s1 + y_1 * c1 + y_c2;

        // 多解像度マップ上の座標に変換
        pt1_x = (map_center - x_3 / map_rate) / multi_Map->rate;
        pt1_y = (map_center - y_3 / map_rate) / multi_Map->rate;

        // 正規化マップで一致判定
        h = -multi_Map->anorm[pt1_x][pt1_y] - multi_Map->norm[pt1_x][pt1_y];
        if (h != 0) hit++;
    }

    return hit / total;
}
```

---

## 5. エッジ抽出処理 (regiongrowing.cpp)

### 5.1 処理目的
CAD図面には家具や設備機器なども描かれており、LRFで検出される壁面とは異なる要素が含まれます。エッジ抽出により、**壁面の輪郭のみを抽出**してマッチング精度を向上させます。

### 5.2 アルゴリズム

```
┌────────────────────────────────────────────────────────────────┐
│                  エッジ抽出処理の流れ                          │
├────────────────────────────────────────────────────────────────┤
│                                                                 │
│  入力: CAD図面 (PNG)                                           │
│  ┌─────────────────────────────────────────┐                  │
│  │ ████████████████████████████████████████│                  │
│  │ █                                      █│ ← 壁面          │
│  │ █    ┌──────┐      ○                  █│                  │
│  │ █    │机    │    (柱)                 █│ ← 障害物        │
│  │ █    └──────┘                         █│                  │
│  │ █                    ◯                █│ ← 初期位置      │
│  │ █                                      █│                  │
│  │ ████████████████████████████████████████│                  │
│  └─────────────────────────────────────────┘                  │
│                                                                 │
│  処理: 領域拡張法 (Region Growing)                             │
│  1. 初期位置から4近傍探索開始                                  │
│  2. 白色画素（閾値200以上）を走査可能領域としてマーク          │
│  3. 黒色画素（閾値200未満）に接触したら輪郭としてマーク        │
│  4. スタックを使って深さ優先探索                               │
│                                                                 │
│  出力: エッジ抽出画像                                          │
│  ┌─────────────────────────────────────────┐                  │
│  │ ████████████████████████████████████████│                  │
│  │ █                                      █│ ← 壁面のみ      │
│  │ █                                      █│                  │
│  │ █                                      █│   机や柱は       │
│  │ █                                      █│   削除される     │
│  │ █                                      █│                  │
│  │ █                                      █│                  │
│  │ ████████████████████████████████████████│                  │
│  └─────────────────────────────────────────┘                  │
│                                                                 │
└────────────────────────────────────────────────────────────────┘
```

### 5.3 主要関数

```cpp
// regiongrowing.cpp
int searchRoom(int px, int py) {
    stack<int> stack_x, stack_y;
    stack_x.push(px);
    stack_y.push(py);

    while (!stack.empty()) {
        int x = stack_x.top();
        int y = stack_y.top();

        for (d = 0; d < 4; d++) {  // 4近傍探索
            int nx = x + vec[d][0];  // 隣接画素
            int ny = y + vec[d][1];

            val = 画素値平均(image[ny][nx]);

            if (val > THcolor) {  // 白色 = 走査可能
                if (未訪問) {
                    room[ny][nx] = 255;  // 走査済みマーク
                    stack.push(nx, ny);
                }
            } else {  // 黒色 = 壁面
                edge[ny][nx] = 255;  // 輪郭マーク
            }
        }
    }
}
```

---

## 6. 多解像度マップの役割

### 6.1 目的
初期位置推定では、広い範囲を探索する必要があります。多解像度マップを使うことで、**粗い解像度で大まかな位置を特定**してから、**細かい解像度で精密に推定**する階層的探索が可能になります。

### 6.2 構造

```cpp
struct multi_map {
    int **mmap;           // 占有マップ
    int **amap;           // 累積マップ
    double **norm;        // 正規化マップ (-1.0 ~ 1.0)
    double **anorm;       // 正規化累積マップ
    int reso;             // 解像度レベル (1, 2, 4, 8)
    double rate;          // スケール率
    struct multi_map *parent;  // 高解像度（親）
    struct multi_map *child;   // 低解像度（子）
};
```

### 6.3 階層的探索

```
解像度8 (粗い)          解像度4            解像度2           解像度1 (詳細)
┌───────────┐        ┌───────────┐     ┌───────────┐     ┌───────────┐
│ ■■■       │        │ ■■■       │     │ ■■■■      │     │ ■■■■■     │
│ ■  ■      │   →    │ ■  ■      │  →  │ ■   ■     │  →  │ ■    ■    │
│ ■■■       │        │ ■■■       │     │ ■■■■      │     │ ■■■■■     │
└───────────┘        └───────────┘     └───────────┘     └───────────┘
   探索範囲:広           探索範囲:中        探索範囲:狭         探索範囲:狭
   精度:低               精度:中            精度:高              精度:高
```

---

## 7. まとめ

### 本システムのSLAMの特徴

1. **事前地図ベース**: 一般的なSLAMとは異なり、CAD図面という事前情報を活用
2. **スキャンマッチング**: LRFデータと既存地図のマッチングが主要処理
3. **遺伝的アルゴリズム**: 最適な自己位置を探索
4. **多解像度探索**: 階層的に精度を上げていく効率的な手法
5. **エッジ抽出**: CAD図面からノイズを除去してマッチング精度向上

### 利点
- 地図構築が不要なため、計算コストが低い
- 既知環境での高精度な位置推定が可能
- CAD図面があれば即座に導入可能

### 制限
- 事前にCAD図面が必要
- CAD図面と実環境の差異が大きいとマッチングが困難
- 動的障害物（人など）への対応は制御側で実装
